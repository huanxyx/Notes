# 非对称加密算法

## Merke-Hellman背包

### 背包问题
已知背包大小和东西大小，请问用哪些东西恰好能正好装满背包。  
背包大小为T，东西大小为An，是否装进背包为1,0。  
则已知背包大小T，东西大小为序列An，求满足条件的1,0序列，这个1,0序列组成了二进制流。  
在此处，序列An为公钥，T为密文，1,0序列为明文。

---

### 具体实现例子
> 明文```P = 0100 1011 1010 0101```,公钥```An = {15,13,9,16}```;

#### 加密
> 常规背包：  
> 难以求解（NP完全问题）

密文为```{13,40,24,29}```。其中第一个13由前4个Pi*Ai得到，即```0*15 + 1*13 + 0*9 + 0*16 = 13```。其他类似。

#### 解密
> 超递增背包：  
> 前n-1项的和小于等于第n项。给定该序列，和背包大小很容易求出对应的二进制序列。  
> 因为当背包介于第k项和第k-1项之间，那么第k-1项必定存在。

私钥是超递增背包```Sn{1,2,4,9},8和17```，明文可以直接由密文和私钥算出来，即```13*8mode17=2=[0100]，40*8mod17=14=[1011]```。其余类似。

#### 构造公钥私钥
> 逆元的定义：  
> 群G中任意一个元素`a`，都在G中有唯一的逆元`a'`，具有性质`aa' = a'a = e`，其中e为群的单位元。   
> 在此`15 (mod 17)`的逆元为`8`，因为`(15*8) mod 17 = 1`。  
> 当a与f互素时，a关于模f的乘法逆元有解。如果不互素，则无解。

-	构造私钥  
	因为序列Sn是超递增的，所以选择一个超递增的序列即可。```{1,2,4,9}```：```S1<S2,S1+S2<S3,S1+S2+S3<S4```。
		由私钥构造公钥
	1. 选定一个乘数w，这里用`15`。
	2. 选择求余的除数m，满足大于私钥序列和，且与w互素(一般选素数)，这里用`17`。 
	3. 求出`w (mod m)`的逆元`w'`：（给解密用）
		- 费马定理：对于任何素数p和任何数a<p，有`a^p mod p = a`。因此设a的逆元为x，即`ax mod p = 1 = a^(p-1)mod p`，所以`x = a^(p-2) mod p`。
		- 所以`15^(17-2) mod 17 = 8`得出逆元`w'`为`8`。
	4. 公钥就为`Ai = Si*w mod m`。

---

### 原理

#### 加密过程
密文：`Tn = An*P = Sn*w*P mod m`
#### 解密过程
`w'*Tn mod m`等于`Sn*P*w'*w mod m`等于`Sn*P mod m`，然后就可以通过超递增背包求出`P`。

---
---

## RSA

### 算法
1. 选择两个大素数`p`和`q`，计算他们的乘积`N = q*p`。
2. 选择与`(p-1)*(q-1)`互素的素数`e`。
3. 计算出`e mod (p-1)*(q-1)`的逆元`d`。
4. 那么公钥为`(N,e)`，私钥为`(N,d)`。
5. 设`M`为明文，`C`为密文。
6. 公钥加密：`C = M^e mod N`。
7. 私钥解密：`M = C^d mod N`。

### 证明
```M = C^d mod N = M^(ed) mod N```
- 由2得出`ed = 1 (mod (p-1)(q-1))`
- 由1得出`φ(N) = φ(p)φ(q) = (p-1)(q-1)`
- 所以就有`ed - 1 = kφ(N)`
- `C^d = M^(ed) = M^((ed-1)+1) = M*M^(ed-1) = M*M^(kφ(N)) mod N`
- 根据欧拉定理有：上式 = `M*1^k = M (mod N)`
- 所以`M = C^d (mod N)`

---

> #### 互质数:

> ##### 定义：
> 两个数的最大公因数为1，则称这个两个数互质。

> ##### 判别方法：
> - 两个不同的质数一定是互质数。（2与7）
> - 一个质数，另一个不为它的倍数，这两个数互质。（3与10）
> - 相邻的两个自然数是互质数。（15与16）
> - 相邻的两个奇数是互质数。（49与51）

---

> #### 费马小定理：

> ##### 定义：
> 如果`p`是质数，且`gcd(a,p) = 1`，那么`a^(p-1) = 1 (mod p)`

> ##### 证明：
> 1. 构造素数`p`的完全剩余系`P = {1,2,3,4,5,...,p-1}`
> 2. 由于`gcd(a,p)=1`，由引理2得：`A = {a,2a,3a,4a,5a,...,(p-1)a}`也是`p`的一个完全剩余系。
> 3. 由完全剩余系的性质得：`1*2*3*...*(p-1) = a*2a*3a*...*(p-1)a  (mod p)`，即`(p-1)! = (p-1)!*a^(p-1)  (mod p)`
> 4. 两边同去`(p-1)!`得到：`a^(p-1) = 1 (mod p)`。得证。

> > 引理1：当`a*c = b*c (mod m)`，且`m与c互质`,那么`a = b (mod m)`。  
> > 引理2：设`m`是一个整数，且`m>1`，`b`是一个整数且`gcd(m,b)=1`。如果`a[1],a[2],a[3],...,a[m]`是模`m`的一个完全剩余系，则`b*a[1],b*a[2],b*a[3],...b*a[m]`也构成模`m`的一个完全剩余系。  
> > > 完全剩余系：如果一个剩余系中包含了正整数n所有可能的余数。那么这个剩余系就被称为是模n的一个完全剩余系。 

---

> #### 欧拉函数：
> ##### 定义：
> 对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目。
> ##### 相关性质：
> - `φ(1)=1`
> - 若是n为质数，那么`φ(n)=n-1`
> - **若是m,n互质，那么`φ(mn)=φ(m)φ(n)`**。
> - 若n是质数p的k次幂，那么`φ(n) = p^k - p^(k-1) = (p-1)p^(k-1)`，因为除了p的倍数外，其他数都跟n互质。

---

> #### 欧拉定理：

> ##### 定义：
> 这是一个关于同余的性质。  
> **若是n，a为正整数，且n,a互质，则`a^φ(n) = 1 (mod n)`**

> ##### 证明：
> 根据费马小定理：`a^(p-1) = 1 (mod p)`，其中a与p互质，且p是质数。  
> 由于p是质数，则`φ(p) = p - 1`，将其代入，则得到`a^φ(n) = 1 (mod n)`。

---

---

## Diffie-Hellman密钥交换算法

### 过程
（1）Alice与Bob确定两个大素数n和g，这两个数不用保密  
（2）Alice选择另一个大随机数x，并计算A如下：`A=g^x mod n`  
（3）Alice将A发给Bob  
（4）Bob  选择另一个大随机数y，并计算B如下：`B=g^y mod n`  
（5）Bob将B发给Alice  
（6）计算秘密密钥K1如下：`K1=B^x mod n`  
（7）计算秘密密钥K2如下：`K2=A^y mod n`  
 K1=K2，因此Alice和Bob可以用其进行加解密

### 安全的原因
攻击者知道p和g，并且截获了Ka和Kb，但是当它们都是非常大的数的时候，依靠这四个数来计算a和b非常困难，这就是离散对数数学难题。 
